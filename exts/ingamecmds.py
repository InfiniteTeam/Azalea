import discord
from discord.ext import commands
import datetime
import asyncio
import datetime
import re
import json
from exts.utils import pager, itemmgr, emojibuttons, errors, charmgr
from exts.utils.basecog import BaseCog
from templates import errembeds

class InGamecmds(BaseCog):
    def __init__(self, client):
        super().__init__(client)
        for cmd in self.get_commands():
            cmd.add_check(self.check.registered)
            if cmd.name not in ['ìºë¦­í„°', 'ë¡œê·¸ì•„ì›ƒ']:
                cmd.add_check(self.check.char_online)

    async def backpack_embed(self, ctx, pgr: pager.Pager):
        items = pgr.get_thispage()
        itemstr = ''
        for one in items:
            founditem = self.imgr.fetch_itemdb_by_id(one['id'])
            icon = founditem['icon']['default']
            name = founditem['name']
            count = one['count']
            itemstr += '{} **{}** ({}ê°œ)\n'.format(icon, name, count)
        embed = discord.Embed(
            title=f'ğŸ’¼ `{ctx.author.name}`ë‹˜ì˜ ê°€ë°©',
            color=self.color['info'],
            timestamp=datetime.datetime.utcnow()
        )
        if items:
            embed.description = itemstr + '```{}/{} í˜ì´ì§€, ì „ì²´ {}ê°œ```'.format(pgr.now_pagenum()+1, len(pgr.pages()), pgr.objlen())
        else:
            embed.description = '\nê°€ë°©ì— ì•„ë¬´ê²ƒë„ ì—†ë„¤ìš”! ~~ì•„, ê³µê¸°ëŠ” ìˆì–´ìš”!~~'
        return embed

    @commands.command(name='ê°€ë°©', aliases=['í…œ'])
    async def _backpack(self, ctx: commands.Context):
        perpage = 4
        items = self.imgr.get_useritems(ctx.author.id)
        
        print(items)
        pgr = pager.Pager(items, perpage=perpage)
        msg = await ctx.send(embed=await self.backpack_embed(ctx, pgr))
        self.msglog.log(ctx, '[ê°€ë°©]')
        for emj in emojibuttons.PageButton.emojis:
            await msg.add_reaction(emj)
        def check(reaction, user):
            return user == ctx.author and msg.id == reaction.message.id and str(reaction.emoji) in emojibuttons.PageButton.emojis
        while True:
            try:
                reaction, user = await self.client.wait_for('reaction_add', check=check, timeout=60*5)
            except asyncio.TimeoutError:
                pass
            else:
                do = await emojibuttons.PageButton.buttonctrl(reaction, user, pgr)
                if asyncio.iscoroutine(do):
                    await asyncio.gather(do,
                        msg.edit(embed=await self.backpack_embed(ctx, pgr)),
                    )

    async def char_embed(self, ctx: commands.Context, pgr: pager.Pager):
        chars = pgr.get_thispage()
        charstr = ''
        for one in chars:
            name = one['name']
            level = one['level']
            chartype = charmgr.CharType.format_chartype(one['type'])
            online = one['online']
            onlinestr = ''
            if online:
                onlinestr = '(**í˜„ì¬ í”Œë ˆì´ì¤‘**)'
            charstr += '**{}** {}\në ˆë²¨: `{}` \\| ì§ì—…: `{}`\n\n'.format(name, onlinestr, level, chartype)
        embed = discord.Embed(
            title=f'ğŸ² `{ctx.author.name}`ë‹˜ì˜ ìºë¦­í„° ëª©ë¡',
            description=charstr,
            color=self.color['info'],
            timestamp=datetime.datetime.utcnow()
        )
        embed.description = charstr + '```{}/{} í˜ì´ì§€, ì „ì²´ {}ìºë¦­í„°```'.format(pgr.now_pagenum()+1, len(pgr.pages()), pgr.objlen())
        return embed

    @commands.group(name='ìºë¦­í„°', aliases=['ìº'], invoke_without_command=True)
    async def _char(self, ctx: commands.Context):
        perpage = 5
        cmgr = charmgr.CharMgr(self.cur, ctx.author.id)
        chars = cmgr.get_characters()
        if not chars:
            await ctx.send(embed=discord.Embed(
                title='ğŸ² ìºë¦­í„°ê°€ í•˜ë‚˜ë„ ì—†ë„¤ìš”!',
                description='`{}ìƒì„±` ëª…ë ¹ìœ¼ë¡œ ìºë¦­í„°ë¥¼ ìƒì„±í•´ì„œ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!'.format(self.prefix),
                color=self.color['warn'],
                timestamp=datetime.datetime.utcnow()
            ))
            return
        pgr = pager.Pager(chars, perpage)
        msg = await ctx.send(embed=await self.char_embed(ctx, pgr))
        self.msglog.log(ctx, '[ìºë¦­í„° ëª©ë¡]')
        if len(pgr.pages()) <= 1:
            return
        for emj in emojibuttons.PageButton.emojis:
            await msg.add_reaction(emj)
        def check(reaction, user):
            return user == ctx.author and msg.id == reaction.message.id and str(reaction.emoji) in emojibuttons.PageButton.emojis
        while True:
            try:
                reaction, user = await self.client.wait_for('reaction_add', check=check, timeout=60*5)
            except asyncio.TimeoutError:
                pass
            else:
                do = await emojibuttons.PageButton.buttonctrl(reaction, user, pgr)
                if asyncio.iscoroutine(do):
                    await asyncio.gather(do,
                        msg.edit(embed=await self.char_embed(ctx, pgr)),
                    )

    @_char.command(name='ìƒì„±', aliases=['ìƒ'])
    async def _char_creacte(self, ctx:commands.Context):
        self._char_creacte.name = 'ìƒì„±'
        cmgr = charmgr.CharMgr(self.cur, ctx.author.id)
        charcount = len(cmgr.get_characters())
        if charcount >= self.config['max_charcount']:
            await ctx.send(embed=discord.Embed(title='âŒ ìºë¦­í„° ìŠ¬ë¡¯ì´ ëª¨ë‘ ì°¼ìŠµë‹ˆë‹¤.', description='ìœ ì €ë‹¹ ìµœëŒ€ ìºë¦­í„° ìˆ˜ëŠ” {}ê°œ ì…ë‹ˆë‹¤.'.format(self.config['max_charcount']), color=self.color['error']))
            self.msglog.log(ctx, '[ìºë¦­í„° ìŠ¬ë¡¯ ë¶€ì¡±]')
            return
        namemsg = await ctx.send(embed=discord.Embed(title='ğŸ· ìºë¦­í„° ìƒì„± - ì´ë¦„', description='ìƒˆ ìºë¦­í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ìºë¦­í„°ì˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.\nì·¨ì†Œí•˜ë ¤ë©´ `ì·¨ì†Œ` ë¥¼ ì…ë ¥í•˜ì„¸ìš”!', color=self.color['ask']))
        self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°]')
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content
        try:
            m = await self.client.wait_for('message', check=check, timeout=60*5)
        except asyncio.TimeoutError:
            await ctx.send(embed=discord.Embed(title='â° ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤!', color=self.color['info']))
            self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°: ì‹œê°„ ì´ˆê³¼]')
        else:
            if m.content == 'ì·¨ì†Œ':
                await ctx.send(embed=discord.Embed(title='âŒ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°: ì·¨ì†Œë¨]')
                return
            elif not (2 <= len(m.content) <= 10):
                await ctx.send(embed=discord.Embed(title='âŒ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ë¦„ì…ë‹ˆë‹¤!', description='ìºë¦­í„° ì´ë¦„ì€ 2ê¸€ì ì´ìƒì´ì—¬ì•¼ í•©ë‹ˆë‹¤.\në‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”!', color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°: ë„ˆë¬´ ì§§ì€ ì´ë¦„]')
                return
            elif not re.match('^[ |ê°€-í£|a-z|A-Z|0-9|\*]+$', m.content):
                await ctx.send(embed=discord.Embed(title='âŒ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ë¦„ì…ë‹ˆë‹¤!', description='ìºë¦­í„° ì´ë¦„ì€ ë°˜ë“œì‹œ í•œê¸€, ì˜ì–´, ìˆ«ìë§Œì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.\në‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”!', color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°: ì˜¬ë°”ë¥´ì§€ ì•Šì€ ì´ë¦„]')
                return
            elif self.cur.execute('select * from chardata where name=%s', m.content) != 0:
                await ctx.send(embed=discord.Embed(title='âŒ ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë¦„ì…ë‹ˆë‹¤!', description='ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”!', color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì´ë¦„ ì§“ê¸°: ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë¦„]')
                return
            else:
                charname = m.content
        typemsg = await ctx.send(embed=discord.Embed(title='ğŸ· ìºë¦­í„° ìƒì„± - ì§ì—…', color=self.color['ask'],
            description="""\
                `{}` ì˜ ì§ì—…ì„ ì„ íƒí•©ë‹ˆë‹¤.
                âš”: ì „ì‚¬
                ğŸ¹: ê¶ìˆ˜
                ğŸ”¯: ë§ˆë²•ì‚¬

                âŒ: ì·¨ì†Œ
            """.format(charname)
        ))
        emjs = ['âš”', 'ğŸ¹', 'ğŸ”¯', 'âŒ']
        for em in emjs:
            await typemsg.add_reaction(em)
        def rcheck(reaction, user):
            return user == ctx.author and typemsg.id == reaction.message.id and str(reaction.emoji) in emjs
        self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì§ì—… ì„ íƒ]')
        try:
            reaction, user = await self.client.wait_for('reaction_add', check=rcheck, timeout=60*5)
        except asyncio.TimeoutError:
            await ctx.send(embed=discord.Embed(title='â° ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤!', color=self.color['info']))
            self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì§ì—… ì„ íƒ: ì‹œê°„ ì´ˆê³¼]')
        else:
            e = str(reaction.emoji)
            if e == 'âŒ':
                await ctx.send(embed=discord.Embed(title='âŒ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì§ì—… ì„ íƒ: ì·¨ì†Œë¨]')
                return
            elif e == 'âš”':
                chartype = charmgr.CharType.Knight()
            elif e == 'ğŸ¹':
                chartype = charmgr.CharType.Archer()
            elif e == 'ğŸ”¯':
                chartype = charmgr.CharType.Wizard()
            
            charcount = len(cmgr.get_characters())
            if charcount >= self.config['max_charcount']:
                await ctx.send(embed=discord.Embed(title='âŒ ìºë¦­í„° ìŠ¬ë¡¯ì´ ëª¨ë‘ ì°¼ìŠµë‹ˆë‹¤.', description='ìœ ì €ë‹¹ ìµœëŒ€ ìºë¦­í„° ìˆ˜ëŠ” {}ê°œ ì…ë‹ˆë‹¤.'.format(self.config['max_charcount']), color=self.color['error']))
                self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ìŠ¬ë¡¯ ë¶€ì¡±]')
                return
            cmgr.add_character(charname, chartype, self.templates['baseitem'])
            if charcount == 0:
                cmgr.change_character(charname)
                desc = 'ì²« ìºë¦­í„° ìƒì„±ì´ë„¤ìš”, ì´ì œ ê²Œì„ì„ ì‹œì‘í•´ë³´ì„¸ìš”!'
            else:
                desc = '`{}ìºë¦­í„° ë³€ê²½` ëª…ë ¹ìœ¼ë¡œ ì´ ìºë¦­í„°ë¥¼ ì„ í…í•´ ê²Œì„ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!'.format(self.prefix)
            await ctx.send(embed=discord.Embed(title='{} ìºë¦­í„°ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤! - `{}`'.format(self.emj.get(ctx, 'check'), charname), description=desc, color=self.color['success']))
            self.msglog.log(ctx, '[ìºë¦­í„° ìƒì„±: ì™„ë£Œ]')

    @_char.command(name='ë³€ê²½')
    async def _char_change(self, ctx: commands.Context, *, name):
        cmgr = charmgr.CharMgr(self.cur, ctx.author.id)
        char = list(filter(lambda x: x['name'] == name, cmgr.get_characters()))
        if char:
            if not char[0]['online']:
                cmgr.change_character(name)
                await ctx.send(embed=discord.Embed(title='{} í˜„ì¬ ìºë¦­í„°ë¥¼ `{}` ìœ¼ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!'.format(self.emj.get(ctx, 'check'), name), color=self.color['success']))
            else:
                await ctx.send(embed=discord.Embed(title=f'â“ ì´ë¯¸ í˜„ì¬ ìºë¦­í„°ì…ë‹ˆë‹¤: `{name}`', description='ì´ ìºë¦­í„°ëŠ” í˜„ì¬ í”Œë ˆì´ ì¤‘ì¸ ìºë¦­í„°ì…ë‹ˆë‹¤.', color=self.color['warn']))
                self.msglog.log(ctx, '[ìºë¦­í„° ë³€ê²½: ì´ë¯¸ í˜„ì¬ ìºë¦­í„°]')
        else:
            await ctx.send(embed=discord.Embed(title=f'â“ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìºë¦­í„°ì…ë‹ˆë‹¤: `{name}`', description='ìºë¦­í„° ì´ë¦„ì´ ì •í™•í•œì§€ í™•ì¸í•´ì£¼ì„¸ìš”!', color=self.color['error']))
            self.msglog.log(ctx, '[ìºë¦­í„° ë³€ê²½: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìºë¦­í„°]')

    @_char_change.error
    async def _e_char_change(self, ctx: commands.Context, error):
        if isinstance(error, commands.MissingRequiredArgument):
            if error.param.name == 'name':
                missing = 'ìºë¦­í„°ì˜ ì´ë¦„'
            await ctx.send(embed=errembeds.MissingArgs.getembed(self.prefix, self.color['error'], missing))

def setup(client):
    cog = InGamecmds(client)
    client.add_cog(cog)